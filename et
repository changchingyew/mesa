[1mdiff --git a/src/gallium/drivers/d3d12/d3d12_screen.cpp b/src/gallium/drivers/d3d12/d3d12_screen.cpp[m
[1mindex d9f9a233037..27f3454c026 100644[m
[1m--- a/src/gallium/drivers/d3d12/d3d12_screen.cpp[m
[1m+++ b/src/gallium/drivers/d3d12/d3d12_screen.cpp[m
[36m@@ -692,6 +692,12 @@[m [mget_debug_interface()[m
    typedef HRESULT(WINAPI *PFN_D3D12_GET_DEBUG_INTERFACE)(REFIID riid, void **ppFactory);[m
    PFN_D3D12_GET_DEBUG_INTERFACE D3D12GetDebugInterface;[m
 [m
[32m+[m[32m   util_dl_library *d3d12core_mod = util_dl_open(UTIL_DL_PREFIX "d3d12core" UTIL_DL_EXT);[m
[32m+[m[32m   if (!d3d12core_mod) {[m
[32m+[m[32m      debug_printf("D3D12core: failed to load D3D12core.DLL\n");[m
[32m+[m[32m      return NULL;[m
[32m+[m[32m   }[m
[32m+[m
    util_dl_library *d3d12_mod = util_dl_open(UTIL_DL_PREFIX "d3d12" UTIL_DL_EXT);[m
    if (!d3d12_mod) {[m
       debug_printf("D3D12: failed to load D3D12.DLL\n");[m
[1mdiff --git a/src/gallium/drivers/d3d12/d3d12_video_enc_h264.cpp b/src/gallium/drivers/d3d12/d3d12_video_enc_h264.cpp[m
[1mindex 94eeed200a1..7b1a3876a51 100644[m
[1m--- a/src/gallium/drivers/d3d12/d3d12_video_enc_h264.cpp[m
[1m+++ b/src/gallium/drivers/d3d12/d3d12_video_enc_h264.cpp[m
[36m@@ -165,24 +165,24 @@[m [md3d12_video_encoder_negotiate_current_h264_slices_configuration(struct d3d12_vid[m
    ///[m
    /// Try to see if can accomodate for multi-slice request by user[m
    ///[m
[31m-   if(picture->multiple_slices_ctrl_present && (picture->multi_slice_ctrl.num_slice_descriptors > 1))[m
[32m+[m[32m   if(picture->num_slice_descriptors > 1)[m
    {[m
       bool bUniformSizeSlices = true; // Last slice can be less for rounding frame size[m
[31m-      for(uint32_t sliceIdx = 1; sliceIdx < picture->multi_slice_ctrl.num_slice_descriptors - 1; sliceIdx++)[m
[32m+[m[32m      for(uint32_t sliceIdx = 1; sliceIdx < picture->num_slice_descriptors - 1; sliceIdx++)[m
       {[m
[31m-         bUniformSizeSlices = bUniformSizeSlices && (picture->multi_slice_ctrl.slices_descriptors[sliceIdx].num_macroblocks == picture->multi_slice_ctrl.slices_descriptors[sliceIdx - 1].num_macroblocks);[m
[32m+[m[32m         bUniformSizeSlices = bUniformSizeSlices && (picture->slices_descriptors[sliceIdx].num_macroblocks == picture->slices_descriptors[sliceIdx - 1].num_macroblocks);[m
       }[m
 [m
       uint32_t mbPerScanline = pD3D12Enc->m_currentEncodeConfig.m_currentResolution.Width / D3D12_VIDEO_H264_MB_IN_PIXELS;[m
[31m-      bool bSliceAligned = ((picture->multi_slice_ctrl.slices_descriptors[0].num_macroblocks % mbPerScanline) == 0);[m
[32m+[m[32m      bool bSliceAligned = ((picture->slices_descriptors[0].num_macroblocks % mbPerScanline) == 0);[m
 [m
       if(!bUniformSizeSlices && d3d12_video_encoder_check_subregion_mode_support(pD3D12Enc, D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_SUBREGIONS_PER_FRAME)) {[m
 [m
          if(D3D12_VIDEO_ENC_FALLBACK_SLICE_CONFIG) { // Check if fallback mode is enabled, or we should just fail without support[m
             // Not supported to have custom slice sizes in D3D12 Video Encode fallback to uniform multi-slice[m
[31m-            D3D12_LOG_INFO("[d3d12_video_encoder_h264] WARNING: Requested slice control mode is not supported: All slices must have the same number of macroblocks. Falling back to encoding uniform %d slices per frame.\n", picture->multi_slice_ctrl.num_slice_descriptors);[m
[32m+[m[32m            D3D12_LOG_INFO("[d3d12_video_encoder_h264] WARNING: Requested slice control mode is not supported: All slices must have the same number of macroblocks. Falling back to encoding uniform %d slices per frame.\n", picture->num_slice_descriptors);[m
             requestedSlicesMode = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_SUBREGIONS_PER_FRAME;[m
[31m-            requestedSlicesConfig.NumberOfSlicesPerFrame = picture->multi_slice_ctrl.num_slice_descriptors;[m
[32m+[m[32m            requestedSlicesConfig.NumberOfSlicesPerFrame = picture->num_slice_descriptors;[m
             D3D12_LOG_INFO("[d3d12_video_encoder_h264] Using multi slice encoding mode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_SUBREGIONS_PER_FRAME with %d slices per frame.\n", requestedSlicesConfig.NumberOfSlicesPerFrame);[m
          } else {[m
             D3D12_LOG_ERROR("[d3d12_video_encoder_h264] Requested slice control mode is not supported: All slices must have the same number of macroblocks. To continue with uniform slices as a fallback, must enable the OS environment variable D3D12_VIDEO_ENC_FALLBACK_SLICE_CONFIG");[m
[36m@@ -194,7 +194,7 @@[m [md3d12_video_encoder_negotiate_current_h264_slices_configuration(struct d3d12_vid[m
          // use D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_ROWS_PER_SUBREGION[m
          // or D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_SUBREGIONS_PER_FRAME[m
          requestedSlicesMode = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_ROWS_PER_SUBREGION;[m
[31m-         requestedSlicesConfig.NumberOfRowsPerSlice = (picture->multi_slice_ctrl.slices_descriptors[0].num_macroblocks / mbPerScanline);[m
[32m+[m[32m         requestedSlicesConfig.NumberOfRowsPerSlice = (picture->slices_descriptors[0].num_macroblocks / mbPerScanline);[m
          D3D12_LOG_INFO("[d3d12_video_encoder_h264] Using multi slice encoding mode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_ROWS_PER_SUBREGION with %d macroblocks rows per slice.\n",[m
             requestedSlicesConfig.NumberOfRowsPerSlice);[m
       [m
[36m@@ -203,14 +203,14 @@[m [md3d12_video_encoder_negotiate_current_h264_slices_configuration(struct d3d12_vid[m
          // Number of macroblocks per slice is not aligned to scanline width, in which case we need[m
          // to use D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_SQUARE_UNITS_PER_SUBREGION_ROW_UNALIGNED[m
          requestedSlicesMode = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_SQUARE_UNITS_PER_SUBREGION_ROW_UNALIGNED;[m
[31m-         requestedSlicesConfig.NumberOfCodingUnitsPerSlice = picture->multi_slice_ctrl.slices_descriptors[0].num_macroblocks;[m
[32m+[m[32m         requestedSlicesConfig.NumberOfCodingUnitsPerSlice = picture->slices_descriptors[0].num_macroblocks;[m
          D3D12_LOG_INFO("[d3d12_video_encoder_h264] Using multi slice encoding mode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_SQUARE_UNITS_PER_SUBREGION_ROW_UNALIGNED with %d macroblocks per slice.\n",[m
             requestedSlicesConfig.NumberOfCodingUnitsPerSlice);[m
       [m
       } else if(D3D12_VIDEO_ENC_FALLBACK_SLICE_CONFIG) { // Check if fallback mode is enabled, or we should just fail without support[m
             // Fallback to single slice encoding (assigned by default when initializing variables requestedSlicesMode, requestedSlicesConfig)[m
             D3D12_LOG_INFO("[d3d12_video_encoder_h264] WARNING: Slice mode for %d slices with bUniformSizeSlices: %d - bSliceAligned %d not supported by the D3D12 driver, falling back to encoding a single slice per frame.\n",[m
[31m-               picture->multi_slice_ctrl.num_slice_descriptors,[m
[32m+[m[32m               picture->num_slice_descriptors,[m
                bUniformSizeSlices,[m
                bSliceAligned);[m
       } else {[m
[1mdiff --git a/src/gallium/frontends/va/picture_h264_enc.c b/src/gallium/frontends/va/picture_h264_enc.c[m
[1mindex ebfc6beb0c4..904379228a9 100644[m
[1m--- a/src/gallium/frontends/va/picture_h264_enc.c[m
[1m+++ b/src/gallium/frontends/va/picture_h264_enc.c[m
[36m@@ -149,15 +149,13 @@[m [mvlVaHandleVAEncSliceParameterBufferTypeH264(vlVaDriver *drv, vlVaContext *contex[m
 [m
    // First slice of the picture[m
    if(pipeSliceDesc.macroblock_address == 0) {[m
[31m-      context->desc.h264enc.multiple_slices_ctrl_present = false;[m
[31m-      context->desc.h264enc.multi_slice_ctrl.num_slice_descriptors = 0;[m
[31m-      memset(&context->desc.h264enc.multi_slice_ctrl.slices_descriptors, 0, sizeof(context->desc.h264enc.multi_slice_ctrl.slices_descriptors));[m
[32m+[m[32m      context->desc.h264enc.num_slice_descriptors = 0;[m
[32m+[m[32m      memset(&context->desc.h264enc.slices_descriptors, 0, sizeof(context->desc.h264enc.slices_descriptors));[m
    }[m
 [m
[31m-   if(context->desc.h264enc.multi_slice_ctrl.num_slice_descriptors < ARRAY_SIZE(context->desc.h264enc.multi_slice_ctrl.slices_descriptors))[m
[32m+[m[32m   if(context->desc.h264enc.num_slice_descriptors < ARRAY_SIZE(context->desc.h264enc.slices_descriptors))[m
    {[m
[31m-      context->desc.h264enc.multi_slice_ctrl.slices_descriptors[context->desc.h264enc.multi_slice_ctrl.num_slice_descriptors++] = pipeSliceDesc;[m
[31m-      context->desc.h264enc.multiple_slices_ctrl_present = (pipeSliceDesc.macroblock_address > 0);[m
[32m+[m[32m      context->desc.h264enc.slices_descriptors[context->desc.h264enc.num_slice_descriptors++] = pipeSliceDesc;[m
    } else {[m
       return VA_STATUS_ERROR_NOT_ENOUGH_BUFFER;[m
    }[m
[1mdiff --git a/src/gallium/include/pipe/p_video_state.h b/src/gallium/include/pipe/p_video_state.h[m
[1mindex cc92e050025..b57f29437d3 100644[m
[1m--- a/src/gallium/include/pipe/p_video_state.h[m
[1m+++ b/src/gallium/include/pipe/p_video_state.h[m
[36m@@ -397,12 +397,6 @@[m [mstruct pipe_h264_enc_slice_desc[m
    enum pipe_h264_slice_type slice_type;[m
 };[m
 [m
[31m-struct pipe_h264_enc_slice_control[m
[31m-{[m
[31m-   unsigned num_slice_descriptors;[m
[31m-   struct pipe_h264_enc_slice_desc slices_descriptors[128];[m
[31m-};[m
[31m-[m
 struct pipe_h264_enc_picture_desc[m
 {[m
    struct pipe_picture_desc base;[m
[36m@@ -439,9 +433,8 @@[m [mstruct pipe_h264_enc_picture_desc[m
    bool enable_vui;[m
    struct hash_table *frame_idx;[m
 [m
[31m-   /* multiple_slices_ctrl_present = false indicates single slice encoding */[m
[31m-   bool multiple_slices_ctrl_present;[m
[31m-   struct pipe_h264_enc_slice_control multi_slice_ctrl; // Can simplify and always pass >=1 . Driver should report in VA cap query if interested or not in multi slice[m
[32m+[m[32m   unsigned num_slice_descriptors;[m
[32m+[m[32m   struct pipe_h264_enc_slice_desc slices_descriptors[128];[m
 };[m
 [m
 struct pipe_h265_enc_seq_param[m
